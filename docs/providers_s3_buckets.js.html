<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: providers/s3/buckets.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: providers/s3/buckets.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteStorage = exports.createStorage = exports.syncTags = exports.syncMetadata = exports.sync = exports.storageExists = void 0;
const path_1 = __importDefault(require("path"));
const client_s3_1 = require("@aws-sdk/client-s3");
const mrmime_1 = require("mrmime");
const objects_1 = require("./objects");
const errors_1 = require("../../errors");
const objects_2 = require("../../utils/objects");
const tags_1 = require("../../utils/tags");
const objects_3 = require("../local/objects");
const storageExists = async (client, name) => {
    try {
        const storages = (await client.send(new client_s3_1.ListBucketsCommand({}))).Buckets ?? [];
        return storages.filter((storage) => storage.Name === name).length > 0;
    }
    catch (error) {
        return false;
    }
};
exports.storageExists = storageExists;
/**
 * Syncs storage with upload and delete actions by comparing local file and storage's object checksums.
 * @memberof S3
 * @param {S3Client} client
 * @param {Storage} storage
 * @param {string} servicePath - Root directory of the service
 * @returns {SyncResult}
 */
const sync = async (client, storage, servicePath) => {
    const { name } = storage;
    const storageExist = await (0, exports.storageExists)(client, name);
    if (!storageExist) {
        throw (0, errors_1.handleMethodError)(new Error(`Storage doesn't exist!`), storage);
    }
    console.log('Syncing storage', { storage: storage.name });
    const files = await (0, objects_3.getLocalFiles)(path_1.default.join(servicePath, storage.localPath), storage);
    const localFilesChecksum = files.map((file) => (0, objects_2.getChecksum)(file.Key, file.ETag));
    const objects = await (0, objects_1.listObjects)(client, storage);
    const storageObjectsChecksum = objects.map((object) => (0, objects_2.getChecksum)(object.Key, object.ETag));
    const filesToUpload = localFilesChecksum.filter((fileChecksum) => !storageObjectsChecksum.includes(fileChecksum));
    const filesToDelete = storageObjectsChecksum.filter((objectChecksum) => !localFilesChecksum.includes(objectChecksum));
    let uploaded = [];
    let deleted = [];
    if (filesToUpload.length > 0 &amp;&amp; storage.actions.includes('upload')) {
        uploaded = await (0, objects_1.uploadObjects)(client, storage, files, filesToUpload);
    }
    if (filesToDelete.length > 0 &amp;&amp; storage.actions.includes('delete')) {
        if (storage.deleteRemoved) {
            const objectsToDelete = objects.filter((object) => filesToDelete.includes((0, objects_2.getChecksum)(object.Key, object.ETag)));
            deleted = await (0, objects_1.deleteObjects)(client, storage, objectsToDelete);
        }
    }
    const result = {
        storage,
        files,
        objects,
        localFilesChecksum,
        storageObjectsChecksum,
        filesToUpload,
        filesToDelete,
        uploaded,
        deleted,
    };
    return result;
};
exports.sync = sync;
/**
 * Syncs storage's metadata.
 * @memberof S3
 * @param {S3Client} client
 * @param {Storage} storage
 * @returns {Promise&lt;SyncMetadataReturn>}
 */
const syncMetadata = async (client, storage) => {
    // Get list of existing objects
    const existingObjects = await (0, objects_1.listObjects)(client, storage);
    const syncedMetadata = [];
    for (const file of existingObjects) {
        console.log("Syncing storage's metadata", {
            storage: storage.name,
            Key: file.Key,
        });
        const detectedContentType = (0, mrmime_1.lookup)(file.Key) ?? storage.defaultContentType;
        try {
            const copyCommand = new client_s3_1.CopyObjectCommand({
                Bucket: storage.name,
                Key: file.Key,
                CopySource: encodeURIComponent(`${storage.name}/${file.Key}`),
                ContentType: detectedContentType,
                MetadataDirective: client_s3_1.MetadataDirective.REPLACE,
                Metadata: storage.metadata,
            });
            const result = await client.send(copyCommand);
            console.log('Metadata synced', {
                storage: storage.name,
                Key: file.Key,
                result,
            });
            // Get Object metadata
            const headCommand = await client.send(new client_s3_1.HeadObjectCommand({
                Bucket: storage.name,
                Key: storage.bucketPrefix
                    ? path_1.default.join(storage.bucketPrefix, `${file.Key}`)
                    : file.Key,
            }));
            console.log('headCommand', headCommand);
            syncedMetadata.push({
                Key: file.Key,
                Bucket: storage.name,
                Metadata: headCommand.Metadata,
            });
        }
        catch (error) {
            (0, errors_1.handleMethodError)(error, storage);
        }
    }
    return syncedMetadata;
};
exports.syncMetadata = syncMetadata;
/**
 * Syncs storage's tags.
 * @memberof S3
 * @param {S3Client} client
 * @param {Storage} storage
 * @returns {TagsSyncResult}
 */
const syncTags = async (client, storage) => {
    console.log("Syncing storage's tags", { storage: storage.name });
    try {
        const existingTagSetCommand = new client_s3_1.GetBucketTaggingCommand({
            Bucket: storage.name,
        });
        const existingTagSet = await client.send(existingTagSetCommand);
        const mergedTagSet = (0, tags_1.mergeTags)(existingTagSet.TagSet, storage.tags ?? {});
        const Tagging = {
            TagSet: mergedTagSet,
        };
        const command = new client_s3_1.PutBucketTaggingCommand({
            Bucket: storage.name,
            Tagging: Tagging,
        });
        await client.send(command);
        console.log("Synced storage's tags", {
            storage: storage.name,
            existingTagSet: existingTagSet.TagSet,
            newTagSet: storage.tags,
            mergedTagSet: mergedTagSet,
        });
        return { storage, result: mergedTagSet };
    }
    catch (error) {
        return { storage, error: (0, errors_1.handleMethodError)(error, storage) };
    }
};
exports.syncTags = syncTags;
const createStorage = async (client, storage) => {
    console.log('Creating storage', { storage: storage.name });
    try {
        const createCommand = new client_s3_1.CreateBucketCommand({
            Bucket: storage.name,
            ObjectLockEnabledForBucket: true,
            ObjectOwnership: 'BucketOwnerPreferred',
        });
        await client.send(createCommand);
        console.log('Storage created', { storage: storage.name });
        const aclCommand = new client_s3_1.PutBucketAclCommand({
            Bucket: storage.name,
            ACL: 'private',
        });
        await client.send(aclCommand);
        console.log('Storage ACL enabled', { storage: storage.name });
        return storage;
    }
    catch (error) {
        throw (0, errors_1.handleMethodError)(error, storage);
    }
};
exports.createStorage = createStorage;
const deleteStorage = async (client, storage) => {
    console.log('Deleting storage', { storage: storage.name });
    try {
        const objects = await (0, objects_1.listObjects)(client, storage);
        const deletedObjects = await (0, objects_1.deleteObjects)(client, storage, objects);
        const deleteCommand = new client_s3_1.DeleteBucketCommand({
            Bucket: storage.name,
        });
        await client.send(deleteCommand);
        console.log('Storage deleted', { storage: storage.name });
        return deletedObjects;
    }
    catch (error) {
        throw (0, errors_1.handleMethodError)(error, storage);
    }
};
exports.deleteStorage = deleteStorage;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-SyncCloudStorage.html">SyncCloudStorage</a></li></ul><h3>Classes</h3><ul><li><a href="module-SyncCloudStorage-SyncCloudStorage.html">SyncCloudStorage</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sun Jan 28 2024 16:55:04 GMT+0100 (GMT+01:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
